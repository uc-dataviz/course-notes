# Introduction to data visualization {#intro-data-viz}

```{r knitr-opts-override, include = FALSE, cache = FALSE}
knitr::opts_chunk$set(echo = FALSE)
```

```{r packages}
library(tidyverse)
library(knitr)
library(stringr)
library(broom)
library(datasauRus)
library(gganimate)
library(socviz)
library(patchwork)
library(rcfss)
library(tidycensus)
library(statebins)
library(here)

theme_set(theme_minimal())
```

## Learning objectives {-}

### Morning

* Introduce myself
* Identify major course objectives
* Review the purpose of data visualizations
* Examine how perception and cognition influence the interpretation of data visualizations
* Assess several historic visualizations for their strengths and weaknesses

### Afternoon

* Review the grammar of graphics and `ggplot2`
* Generate clean, interpretable visualizations

## Assigned readings {-}

* Chapters 1-3, @healy2018data - accessible via the [book's website](https://socviz.co/)
* Chapter 2, @cairo2016 - accessible via [electronic course reserve](https://canvas.uchicago.edu/courses/29097/external_tools/50)

## Why visualize data?

Research methods classes in graduate school generally teach important skills such as probability and statistical theory, regression, analysis of variance (ANOVA), maximum likelihood estimation (MLE), etc. While these are important methods for analyzing data and assessing research questions, sometimes drawing a picture (aka **visualization**) can be more precise than conventional statistical computations.^[Example drawn from [*The Datasaurus Dozen* by Justin Matejka and George Fitzmaurice](https://www.autodeskresearch.com/publications/samestats).]

### Anscombe's quartet

```{r anscombe}
# tidy the dataset
# source: https://gist.github.com/amoeba/7576126
anscombe_tidy <- map_df(.x = 1:4, ~ tibble(
  set = .x,
  x = anscombe[, .x],
  y = anscombe[, .x + 4]
))

ggplot(
  data = anscombe_tidy,
  mapping = aes(x = x, y = y)
) +
  geom_point() +
  geom_smooth(method = "lm", se = FALSE, fullrange = TRUE) +
  facet_wrap(~set) +
  labs(
    title = "Anscombe's quartet",
    x = expression(X),
    y = expression(Y)
  )
```

### Datasaurus dozen

```{r datasaurus-graph}
ggplot(datasaurus_dozen, aes(x = x, y = y)) +
  geom_point() +
  theme_minimal() +
  transition_states(dataset, 3, 1) +
  ease_aes("cubic-in-out")
```

```{r datasaurus-graph-static, fig.height = 8, fig.width = 8}
ggplot(datasaurus_dozen, aes(x = x, y = y)) +
  facet_wrap(~dataset) +
  geom_point() +
  theme_minimal()
```

Remarkably each of the datasets have the same summary statistics and linear relationships, yet they are drastically different in appearance! A good picture tells the reader much more than any table or text can provide.

### Outliers

```{r south-africa-outlier}
knitr::include_graphics("https://socviz.co/assets/ch-01-jackman-outlier.png")
```

## What makes visualizations bad

### Lies

```{r gas}
knitr::include_graphics(here("images", "cost_of_gas.jpg"))
```

### Dual axes

```{r nic-cage}
knitr::include_graphics(here("images", "drowning_cage.jpeg"))
```

### Lacking functionality

```{r bush-tax-cuts}
knitr::include_graphics(here("images", "Bush_cuts2.png"))
```

```{r gun-deaths}
knitr::include_graphics(here("images", "stand_your_ground.jpg"))
```

### Junky

```{r death-penalty}
knitr::include_graphics(here("images", "death_penalty.jpg"))
```

## Purpose of visualizations

A **visualization** is "any kind of visual representation of information designed to enable communication, analysis, discovery, exploration, etc."^[Chapter 1, @cairo2016] However what you seek to communicate can vary widely depending on your goals, and therefore effects the type of visualization you should design.

### Statistical graphics

**Statistical graphics** seek to visualize abstract data typically of the quantitative form. The goal is to convey data accurately and reveal the underlying structure, but are generally not explorative and interactive and may not always yield an aesthetically pleasing form.

#### Examples

##### Double-time bar charts

```{r double-bar-chart, fig.cap = "Double-time bar chart of crime in the city of San Francisco, 2009-10. Source: [Visualizing Time with the Double-Time Bar Chart](https://dougmccune.com/blog/2011/04/26/visualizing-time-with-the-double-time-bar-chart/)"}
knitr::include_graphics("https://dougmccune.com/blog/wp-content/uploads/2011/04/burglary1.png")
```
    
* Each set of 24 bars show the same data. The top bars run from midnight to 11pm. The bottom bars run from noon to 11am.
* Highlighted regions represent 6-5 (6am-5pm; 6pm-5am)
* Colors represent (roughly) day and night (yellow for day, blue for night)
* Enables representing trends over a 24 hour period without breaking arbitrarily at midnight

```{r double-bar-chart-facet, fig.cap = "Double-time bar chart of crime in the city of San Francisco, 2009-10. Source: [Visualizing Time with the Double-Time Bar Chart](https://dougmccune.com/blog/2011/04/26/visualizing-time-with-the-double-time-bar-chart/)"}
knitr::include_graphics("https://dougmccune.com/blog/wp-content/uploads/2011/04/small_multiples_small.png")
```

* Compare different categories of crimes using **small multiples** (aka **facets** in `ggplot2` language)

### Information dashboards

**Information dashboards** are popular in business and industry. They visualize abstract data, frequently (though not always) over time. The goal is to convey large amounts of information quickly and identify outliers and trends. The downside is that they can become extremely dense.

#### Examples

* [COVID-19 United States Cases by County](https://coronavirus.jhu.edu/us-map)
* [California COVID Assessment Tool](https://calcat.covid19.ca.gov/cacovidmodels/) - built in Shiny!

### Infographics

**Infographics** depict abstract data in an effort to be eye-catching and capture attention, and convey information quickly. Unfortunately they are frequently not accurate, do not use space efficiently, and may not encourage exploration of the data.

#### Examples

```{r sexual-sun-stroke, fig.cap = "Extremely sexual sun stroking. Source: [The top 10 worst infographics ever created](https://klientboost.com/ppc/the-top-10-worst-infographics-ever-created/)"}
knitr::include_graphics("https://klientboost.com/wp-content/uploads/2013/05/1.jpg")
```

```{r terrible-area-chart, fig.cap = "Source: [11 Most Useless And Misleading Infographics On The Internet](http://io9.gizmodo.com/11-most-useless-and-misleading-infographics-on-the-inte-1688239674)"}
knitr::include_graphics("https://i.kinja-img.com/gawker-media/image/upload/b5icpqdsnzsdaezvnrm1.jpg")
```

```{r paid-maternity-leave, fig.cap = "Source: [WTF Visualizations](http://viz.wtf/post/158594346945/from-this-i-glean-1-the-us-has-no-paid)"}
knitr::include_graphics("https://68.media.tumblr.com/fd2be427c6794cc8e25bc23c42da73aa/tumblr_omvcm7m9va1sgh0voo1_1280.jpg")
```

### Informative art

**Informative art** visualizes abstract data in an effort to make visualization ambient or a part of everyday life. The goal is to aesthetically please the audience, not to be informative.

#### Examples

* [Debussy, Clair de lune (piano music)](https://youtu.be/LlvUepMa31o?t=8s)
    
## What makes a good visualization

### Dr. John Snow and cholera outbreak in London

```{r snow, fig.cap = "Original map made by John Snow in 1854. Cholera cases are highlighted in black. [Source: Wikipedia.](https://commons.wikimedia.org/wiki/File:Snow-cholera-map-1.jpg)"}
knitr::include_graphics("https://upload.wikimedia.org/wikipedia/commons/thumb/2/27/Snow-cholera-map-1.jpg/819px-Snow-cholera-map-1.jpg")
```

At this point in time the theory of bacteria was not widely accepted by the medical community or the public.^[Drawn from [John Snow and the Broad Street Pump](http://www.ph.ucla.edu/epi/snow/snowcricketarticle.html)] A mother washed her baby's diaper in a well in 1854 in London, sparking an outbreak of **cholera**, an intestinal disease that causes vomiting, diarrhea, and eventually death. This disease had presented itself previously in London but its cause was still unknown. Dr. John Snow lived in Soho, the suburb of London where the disease manifested in 1854, and wanted to understand how cholera spreads through a population (an early day epidemiologist). Snow recorded the location of individuals who contracted cholera, including their places of residence and employment. He used this information to draw a map of the region, recording the location of individuals who contracted the disease. They seemed to be clustered around the well pump along Broad Street. Snow used this map to deduce the source of the outbreak was the well, along the way ruling out other causes by noting individuals who lived in the area and did not contract cholera, identifying that these individuals did not drink from the well. Based on this information, the government removed the handle from the well pump so the public could not draw water from it. As a result, the cholera epidemic ended.

* What makes this a good visualization?
* One of the earliest examples of statistical visualizations

### Minard's map of Napoleon's march on Russia

```{r minard-orig, fig.cap = "Charles Minard's 1869 chart showing the number of men in Napoleonâ€™s 1812 Russian campaign army, their movements, as well as the temperature they encountered on the return path. [Source: Wikipedia.](https://en.wikipedia.org/wiki/File:Minard.png)"}
knitr::include_graphics("https://upload.wikimedia.org/wikipedia/commons/2/29/Minard.png")
```

```{r minard-translate, fig.cap = "English translation of Minard's map. [Source: Wikipedia.](https://commons.wikimedia.org/wiki/File:Minard_Update.png)"}
knitr::include_graphics("https://upload.wikimedia.org/wikipedia/commons/e/e2/Minard_Update.png")
```

This illustration is identifed in Edward Tufte's **The Visual Display of Quantitative Information** as one of "the best statistical drawings ever created".^[@tufte2001visual] It also demonstrates a very important rule of warfare: [never invade Russia in the winter](https://en.wikipedia.org/wiki/Russian_Winter). In 1812, Napoleon ruled most of Europe. He wanted to seize control of the British islands, but could not overcome the UK defenses. He decides to impose an embargo to weaken the nation in preparation for invasion, but Russia refused to participate. Angered at this decision, Napoleon launched an invasion of Russia with over 400,000 troops in the summer of 1812. Russia is unable to defeat Napoleon in battle, but instead waged a war of attrition. The Russian army was in near constant retreat, burning or destroying anything of value along the way to deny France usable resources. While Napoleon's army maintained the military advantage, his lack of food and the emerging European winter decimated his forces. He left France with an army of approximately 422,000 soldiers; he returned to France with just 10,000.

Charles Minard's map is a stunning achievement for his era. It incorporates data across six dimensions to tell the story of Napoleon's failure. The graph depicts:

* Size of the army
* Location in two-dimensions (latitude and longitude)
* Direction of the army's movement
* Temperature on dates during Napoleon's retreat

What makes this such an effective visualization?^[Source: [Dataviz History: Charles Minard's Flow Map of Napoleon's Russian Campaign of 1812](https://datavizblog.com/2013/05/26/dataviz-history-charles-minards-flow-map-of-napoleons-russian-campaign-of-1812-part-5/)]

* Forces visual comparisons (colored bands for advancing and retreating)
* Shows causality (temperature chart)
* Captures multivariate complexity
* Integrates text and graphic into a coherent whole (perhaps the first infographic, and done well!)
* Illustrates high quality content (based on reliable data)
* Places comparisons adjacent to each other (all on the same page, no jumping back and forth between pages)
* Mimimalistic in nature (avoids what we will later term "chart junk")

> Data maps were one of the first data visualizations, though it took thousands of years after the first cartographic maps before data maps came together.

## Perception and data visualization

* Driven by science
* Lots to learn here, but we don't have time this week to dive in deep!
* Important to remember human perception and cognition is a process - design visualizations remembering this fact
* Work to simplify perception so the story is clear and easy to tell

### Visual tasks and decoding graphs

> A graphical form that involves elementary perceptual tasks that lead to more accurate judgments than another graphical form (with the same quantitiative information) will result in better organization and increase the chances of a correct perception of patterns and behavior.

```{r cleveland, fig.cap = "Figure 1.22 from @healy2018data"}
knitr::include_graphics("https://socviz.co/assets/ch-01-cleveland-task-types.png")
```

```{r cleveland-replication, fig.cap = "Figure 1.23 from @healy2018data"}
knitr::include_graphics("https://socviz.co/assets/ch-01-heer-bostock-results.png")
```

### Channels and decoding information

```{r channels-ordered-data, fig.cap = "Figure 1.24 from @healy2018data"}
knitr::include_graphics("https://socviz.co/assets/ch-01-channels-for-cont-data-vertical.png")
```

```{r channels-unordered-data, fig.cap = "Figure 1.26 from @healy2018data"}
knitr::include_graphics("https://socviz.co/assets/ch-01-channels-for-cat-data-vertical.png")
```

### Example of decoding information

#### Bar chart vs. pie chart

```{r bar-pie}
gss_auth <- gss_colrac %>%
  count(authoritarianism) %>%
  mutate(authoritarianism = factor(authoritarianism)) %>%
  mutate(pct = n / sum(n))

# bar chart
auth_bar <- ggplot(gss_auth, aes(authoritarianism, pct, fill = authoritarianism)) +
  geom_col() +
  scale_y_continuous(labels = scales::percent) +
  scale_fill_brewer(palette = "OrRd", guide = FALSE) +
  labs(x = "Authoritarianism scale\n(higher indicates more support for authoritarian government)",
       y = "Percentage of respondents")

# pie chart
auth_pie <- ggplot(gss_auth, aes(x = factor(1), y = pct, fill = authoritarianism)) +
  geom_col(width = 1) +
  geom_text(aes(label = authoritarianism), position = position_stack(vjust = 0.5), size = 7) +
  coord_polar(theta = "y", direction = -1) +
  scale_fill_brewer(palette = "OrRd", guide = FALSE) +
  labs(x = "Authoritarianism scale\n(higher indicates more support for authoritarian government)",
       y = "Percentage of respondents") +
  theme_void(base_size = rcfss::base_size)

auth_bar +
  auth_pie +
  plot_annotation(title = "Public support for authoritarianism",
                  caption = "Source: General Social Survey (2012)",
                  tag_levels = "A") +
  plot_layout(widths = c(50, 50))
```

### Choropleths

```{r maps, fig.asp = .8}
us_sf <- get_acs(geography = "state", 
                 variables = c(medincome = "B19013_001"), 
                 year = 2016,
                 geometry = TRUE,
                 shift_geo = TRUE)

trump_map <- left_join(us_sf, election, by = c("NAME" = "state")) %>%
  ggplot(mapping = aes(fill = pct_trump)) +
  geom_sf() +
  scale_fill_distiller(palette = "Reds", labels = scales::percent_format(scale = 1)) +
  labs(fill = "Percent Trump") +
  theme_void() +
  theme(legend.position = "bottom")

trump_statebins <- ggplot(data = election, mapping = aes(state = state, fill = pct_trump)) +
  geom_statebins()  +
  coord_equal() +
  scale_fill_distiller(palette = "Reds", labels = scales::percent_format(scale = 1), guide = FALSE) +
  labs(fill = "Percent Trump") +
  theme_statebins(base_size = rcfss::base_size) +
  theme(legend.position = "bottom")

# lollipop chart
trump_lollipop <- ggplot(data = election,
                         mapping = aes(y = reorder(state, pct_trump), x = pct_trump,
                                       color = pct_trump)) +
  geom_pointrange(aes(xmin = 0, xmax = pct_trump),
                  fatten = 3, size = .7) +
  scale_color_distiller(palette = "Reds", labels = scales::percent_format(scale = 1), guide = FALSE) +
  labs(y = NULL,
       x = "Percent Trump") +
  theme_minimal(base_size = rcfss::base_size * .6)

(trump_lollipop | (trump_map / trump_statebins +
                     plot_layout(guides = "collect"))) +
  plot_annotation(title = "2016 US Presidential Election", tag_levels = "A") +
  plot_layout(ncol = 2, byrow = FALSE) &
  theme(legend.position = 'bottom')
```

## Identifying appropriate graphical forms

Once we learn more about elementary perceptual tasks and why some channels are better than others, choosing appropriate graphical forms will become more complex as we more carefully consider the specific marks and channels used to communicate our data. Here, we will identify at a high-level some suggestions to follow when determining an appropriate graphical form and consider several basic types of charts and their appropriate use cases.

### Cairo's *Truthful Art* suggested approach

1. Think about the task or tasks you want to enable
1. Try different graphic forms
1. Arrange the components of the graphic
1. Test the outcomes

These suggestions are a bit vague, but I really like the last one: **test the outcomes**.^[Chapter 5 in @cairo2016] Something that appears intuitive to you may not appear the same way to a different audience. Especially in the context of statistical graphics and presenting academic results, you become steeped in the data so much that you assume everyone else has lots of background knowledge about your dataset. However they do not possess this knowledge: that's why they're reading your visualization.

### What is the story?

Another of Cairo's suggestions is really useful: what is the story you want to tell?

```{r piketty, fig.cap = "Source: @cairo2016"}
knitr::include_graphics(here("images", "ta_piketty.jpeg"))
```

Consider the bottom two graphs: which is the better graph? Well, it depends. If our goal is the same as Piketty's, then we want to compare Europe to the rest of the continents. The stacked area chart accomplishes this goal just fine by placing Europe on the bottom, sitting at the baseline. However if the goal is to compare all continents with one another, then this graph does not do a good job. Making comparisons with Africa and America are difficult because their baselines are dependent on Europe's GDP percentage. Instead, we'd rather all continents start at the same baseline to enable easy comparisons, which is what the non-stacked grouped line chart accomplishes. Depending on your story, you want to choose a graph/chart type that best tells that story.

## Grammar of graphics

Google defines a **grammar** as "the whole system and structure of a language or of languages in general, usually taken as consisting of syntax and morphology (including inflections) and sometimes also phonology and semantics".^[[Google](https://www.google.com/search?q=grammar)] Others consider a grammar to be "the fundamental principles or rules of an art or science".^[[Wickham, Hadley. (2010) "A Layered Grammar of Graphics". *Journal of Computational and Graphical Statistics*, 19(1).](http://www.jstor.org.proxy.uchicago.edu/stable/25651297)] Applied to visualizations, a **grammar of graphics** is a grammar used to describe and create a wide range of statistical graphics.^[[Wilkinson, Leland. (2005). *The Grammar of Graphics*. (UChicago authentication required)](http://link.springer.com.proxy.uchicago.edu/book/10.1007%2F0-387-28695-0)]

The **layered grammar of graphics** approach is implemented in [`ggplot2`](https://cran.r-project.org/web/packages/ggplot2/index.html), a widely used graphics library for R. All graphics in this library are built using a layered approach, building layers up to create the final graphic.

### Components of the layered grammar of graphics

* Layer
    * Data
    * Mapping
    * Statistical transformation (stat)
    * Geometric object (geom)
    * Position adjustment (position)
* Scale
* Coordinate system (coord)
* Faceting (facet)
* Defaults
    * Data
    * Mapping

### Layer

**Layers** are used to create the objects on a plot. They are defined by five basic parts:

1. Data
1. Mapping
1. Statistical transformation (stat)
1. Geometric object (geom)
1. Position adjustment (position)

Layers are typically related to one another and share many common features. For instance, multiple layers can be built using the same underlying data. An example would be a scatterplot overlayed with a smoothed regression line to summarize the relationship between two variables:

```{r layers, echo = FALSE}
set.seed(1234)

tibble(
  x = runif(50),
  y = x + rnorm(50, 0, .2)
) %>%
  ggplot(mapping = aes(x = x, y = y)) +
  geom_point() +
  geom_smooth(method = "lm", se = FALSE) +
  labs(
    title = "A plot with two layers",
    subtitle = "A scatterplot and a smoothing line"
  )
```

### Data and mapping

**Data** defines the source of the information to be visualized, but is independent from the other elements. So a layered graphic can be built which utilizes different data sources while keeping the other components the same.

For our running example, let's use the `county_data` dataset in the `socviz` package.^[Run `?county_data` in the console to get more information about this dataset.]

```{r county-data}
county_data <- as_tibble(county_data) %>%
  drop_na(hh_income, per_dem_2016, flipped, pop_dens)
DT::datatable(data = county_data, options = list(scrollX = TRUE))
```

**Mapping** defines how the variables are applied to the plot. So if we were graphing information from `county_data`, we might map a county's median household income to the $x$ position and 2016 Democratic presidential vote percentage to the $y$ position.

```{r mapping, dependson = "county-data", echo = TRUE}
county_data %>%
  select(hh_income, per_dem_2016) %>%
  rename(
    x = hh_income,
    y = per_dem_2016
  )
```

### Statistical transformation

A **statistical transformation** (*stat*) transforms the data, generally by summarizing the information. For instance, in a bar graph you typically are not trying to graph the raw data because this doesn't make any inherent sense. Instead, you might summarize the data by graphing the total number of observations within a set of categories. Or if you have a dataset with many observations, you might transform the data into a smoothing line which summarizes the overall pattern of the relationship between variables by calculating the mean of $y$ conditional on $x$.

A stat is a function that takes in a dataset as the input and returns a dataset as the output; a stat can add new variables to the original dataset, or create an entirely new dataset. So instead of graphing this data in its raw form:

```{r stat_raw, dependson = "county-data", echo = TRUE}
county_data %>%
  select(state)
```

You would transform it to:

```{r stat_transform, dependson = "county-data", echo = TRUE}
county_data %>%
  count(state)
```

```{block2, type = "rmdnote", echo = TRUE}
Sometimes you don't need to make a statistical transformation. For example, in a scatterplot you use the raw values for the $x$ and $y$ variables to map onto the graph. In these situations, the statistical transformation is an *identity* transformation - the stat simply passes in the original dataset and exports the exact same dataset.

```

### Geometric objects

**Geometric objects** (*geoms*) control the type of plot you create. Geoms are classified by their dimensionality:

* 0 dimensions - point, text
* 1 dimension - path, line
* 2 dimensions - polygon, interval

Each geom can only display certain **aesthetics** or visual attributes of the geom. For example, a point geom has position, color, shape, and size aesthetics.

```{r geom_point, dependson = "county-data", echo = TRUE}
ggplot(
  data = county_data,
  mapping = aes(
    x = hh_income,
    y = per_dem_2016,
    color = flipped
  )
) +
  geom_point() +
  ggtitle("A point geom with position and color aesthetics")
```

* Position defines where each point is drawn on the plot
* Color defines the color of each point. Here the color is determined by whether the county flipped parties from 2012 to 2016

Whereas a bar geom has position, height, width, and fill color.

```{r geom_bar, dependson = "county-data", echo = TRUE}
ggplot(data = county_data, mapping = aes(x = pop_dens)) +
  geom_bar() +
  ggtitle("A bar geom with position and height aesthetics")
```

* Position determines the starting location (origin) of each bar
* Height determines how tall to draw the bar. Here the height is based on the number of observations in the dataset for each population density category.

### Position adjustment

Sometimes with dense data we need to adjust the position of elements on the plot, otherwise data points might obscure one another. Bar plots frequently **stack** or **dodge** the bars to avoid overlap:

```{r position_dodge, dependson = "county-data", echo = TRUE}
count(x = county_data, su_gun4, pop_dens) %>%
  ggplot(mapping = aes(x = pop_dens, y = n, fill = su_gun4)) +
  geom_bar(stat = "identity") +
  ggtitle(label = "A stacked bar chart")

count(x = county_data, su_gun4, pop_dens) %>%
  ggplot(mapping = aes(x = pop_dens, y = n, fill = su_gun4)) +
  geom_bar(stat = "identity", position = "dodge") +
  ggtitle(label = "A dodged bar chart")
```

Sometimes scatterplots with few unique $x$ and $y$ values are **jittered** (random noise is added) to reduce overplotting.

```{r position, dependson = "county-data", echo = TRUE}
ggplot(data = county_data, mapping = aes(x = pop_dens, y = per_dem_2016)) +
  geom_point() +
  ggtitle("A point geom with obscured data points")

ggplot(data = county_data, mapping = aes(x = pop_dens, y = per_dem_2016)) +
  geom_jitter() +
  ggtitle("A point geom with jittered data points")
```

### Scale

A **scale** controls how data is mapped to aesthetic attributes, so we need one scale for every aesthetic property employed in a layer. For example, this graph defines a scale for color:

```{r scale_color, dependson = "county-data", echo = TRUE}
ggplot(
  data = county_data,
  mapping = aes(
    x = hh_income,
    y = per_dem_2016,
    color = pop_dens
  )
) +
  geom_point()
```

Note that the scale is consistent - every point for a different population density category is the same color. The scale can be changed to use a different color palette:

```{r scale_color_palette, dependson = "county-data", echo = TRUE}
ggplot(
  data = county_data,
  mapping = aes(
    x = hh_income,
    y = per_dem_2016,
    color = pop_dens
  )
) +
  geom_point() +
  scale_color_brewer(type = "seq")
```

Now we are using a different palette, but the scale is still consistent.

### Coordinate system

A **coordinate system** (*coord*) maps the position of objects onto the plane of the plot, and controls how the axes and grid lines are drawn. Plots typically use two coordinates ($x, y$), but could use any number of coordinates. Most plots are drawn using the [**Cartesian coordinate system**](https://en.wikipedia.org/wiki/Cartesian_coordinate_system):

```{r coord_cart}
x1 <- c(1, 10)
y1 <- c(1, 5)
p <- qplot(x = x1, y = y1, geom = "blank", xlab = NULL, ylab = NULL) +
  theme_bw()
p +
  ggtitle(label = "Cartesian coordinate system")
```

This system requires a fixed and equal spacing between values on the axes. That is, the graph draws the same distance between 1 and 2 as it does between 5 and 6. The graph could be drawn using a [**semi-log coordinate system**](https://en.wikipedia.org/wiki/Semi-log_plot) which logarithmically compresses the distance on an axis:

```{r coord_semi_log}
p +
  coord_trans(y = "log10") +
  ggtitle(label = "Semi-log coordinate system")
```

Or could even be drawn using [**polar coordinates**](https://en.wikipedia.org/wiki/Polar_coordinate_system):

```{r coord_polar}
p +
  coord_polar() +
  ggtitle(label = "Polar coordinate system")
```

### Faceting

**Faceting** can be used to split the data up into subsets of the entire dataset. This is a powerful tool when investigating whether patterns are the same or different across conditions, and allows the subsets to be visualized on the same plot (known as **conditioned** or **trellis** plots). The faceting specification describes which variables should be used to split up the data, and how they should be arranged.

```{r facet, dependson = "county-data", echo = TRUE}
ggplot(
  data = county_data,
  mapping = aes(x = hh_income, y = per_dem_2016)
) +
  geom_point() +
  facet_wrap(~pop_dens)
```

### Defaults

Rather than explicitly declaring each component of a layered graphic (which will use more code and introduces opportunities for errors), we can establish intelligent defaults for specific geoms and scales. For instance, whenever we want to use a bar geom, we can default to using a stat that counts the number of observations in each group of our variable in the $x$ position.

Consider the following scenario: you wish to generate a scatterplot visualizing the relationship between household income and 2016 presidential Democratic vote share. With no defaults, the code to generate this graph is:

```{r default, dependson = "county-data", echo = TRUE}
ggplot() +
  layer(
    data = county_data, mapping = aes(x = hh_income, y = per_dem_2016),
    geom = "point", stat = "identity", position = "identity"
  ) +
  scale_x_continuous() +
  scale_y_continuous() +
  coord_cartesian()
```

The above code:

* Creates a new plot object (`ggplot`)
* Adds a layer (`layer`)
    * Specifies the data (`county_data`)
    * Maps household income to the $x$ position and 2016 Democratic vote share to the $y$ position (`mapping`)
    * Uses the point geometric transformation (`geom = "point"`)
    * Implements an identity transformation and position (`stat = "identity"` and `position = "identity"`)
* Establishes two continuous position scales (`scale_x_continuous` and `scale_y_continuous`)
* Declares a cartesian coordinate system (`coord_cartesian`)

How can we simplify this using intelligent defaults?

1. We only need to specify one geom and stat, since each geom has a default stat.
1. Cartesian coordinate systems are most commonly used, so it should be the default.
1. Default scales can be added based on the aesthetic and type of variables.
    * Continuous values are transformed with a linear scaling.
    * Discrete values are mapped to integers.
    * Scales for aesthetics such as color, fill, and size can also be intelligently defaulted.

Using these defaults, we can rewrite the above code as:

```{r default2, dependson = "county-data", echo = TRUE}
ggplot() +
  geom_point(
    data = county_data,
    mapping = aes(x = hh_income, y = per_dem_2016)
  )
```

This generates the exact same plot, but uses fewer lines of code. Because multiple layers can use the same components (data, mapping, etc.), we can also specify that information in the `ggplot()` function rather than in the `layer()` function:

```{r default3, dependson = "county-data", echo = TRUE}
ggplot(
  data = county_data,
  mapping = aes(x = hh_income, y = per_dem_2016)
) +
  geom_point()
```

And as we will learn, function arguments in R use specific ordering, so we can omit the explicit call to `data` and `mapping`:

```{r default4, dependson = "county-data", echo = TRUE}
ggplot(county_data, aes(hh_income, per_dem_2016)) +
  geom_point()
```

With this specification, it is easy to build the graphic up with additional layers, without modifying the original code:

```{r default5, dependson = "county-data", echo = TRUE}
ggplot(county_data, aes(hh_income, per_dem_2016)) +
  geom_point() +
  geom_smooth()
```

Because we called `aes(hh_income, per_dem_2016)` within the `ggplot()` function, it is automatically passed along to both `geom_point()` and `geom_smooth()`. If we fail to do this, we get an error:

```{r default6, dependson = "county-data", echo = TRUE, error = TRUE}
ggplot(county_data) +
  geom_point(aes(hh_income, per_dem_2016)) +
  geom_smooth()
```

## Building Minard's map in R

```{r minard_data, echo = TRUE}
# get data on troop movements and city names
troops <- read_table("https://cfss.uchicago.edu/data/minard-troops.txt")
cities <- read_table("https://cfss.uchicago.edu/data/minard-cities.txt")
troops
cities
```

### Exercise: Define the grammar of graphics for this graph

<details> 
  <summary>**Click here for solution**</summary>
  <p>
  
* Layer
    * Data - `troops`
    * Mapping
        * $x$ and $y$ - troop position (`lat` and `long`)
        * Size - `survivors`
        * Color - `direction`
    * Statistical transformation (stat) - `identity`
    * Geometric object (geom) - `path`
    * Position adjustment (position) - none
* Layer
    * Data - `cities`
    * Mapping
        * $x$ and $y$ - city position (`lat` and `long`)
        * Label - `city`
    * Statistical transformation (stat) - `identity`
    * Geometric object (geom) - `text`
    * Position adjustment (position) - none
* Scale
    * Size - range of widths for troop `path`
    * Color - colors to indicate advancing or retreating troops
* Coordinate system - map projection (Mercator or something else)
* Faceting - none

  </p>
</details>

### Write the R code

```{block2, type = "rmdnote", echo = TRUE}
Download the necessary data files using `usethis::use_course("css-data-mining-viz/grammar-of-graphics")`.

```

First we want to build the layer for the troop movement:

```{r plot_troops, echo = TRUE}
plot_troops <- ggplot(data = troops, mapping = aes(x = long, y = lat)) +
  geom_path(mapping = aes(
    size = survivors,
                color = direction,
                group = group)
    )
plot_troops
```

Next let's add the cities layer:

```{r plot_cities, dependson = 'plot_troops', echo = TRUE}
plot_both <- plot_troops + 
  geom_text(data = cities,
            mapping = aes(label = city), size = 4)
plot_both
```

Now that the basic information is on there, we want to clean up the graph and polish the visualization by:

* Adjusting the size scale aesthetics for troop movement to better highlight the loss of troops over the campaign.
* Change the default colors to mimic Minard's original grey and tan palette.
* Change the coordinate system to a map-based system that draws the $x$ and $y$ axes at equal intervals.
* Give the map a title and remove the axis labels.

```{r plot_clean, dependson = 'plot_cities', echo = TRUE}
plot_polished <- plot_both +
  scale_size(range = c(0, 12),
             breaks = c(1e04, 5e04, 1e05, 3e05),
             labels = scales::comma) + 
  scale_color_manual(values = c("tan", "grey50")) +
  coord_map() +
  labs(title = "Map of Napoleon's Russian campaign of 1812",
       x = NULL,
       y = NULL)
plot_polished
```

Finally we can change the default `ggplot` theme to remove the background and grid lines, as well as the legend for advance/retreat:

```{r plot_final, dependson = 'plot_clean', echo = TRUE}
plot_polished +
  theme_void() +
  scale_color_manual(values = c("tan", "grey50"), guide = FALSE)
```

## Session info {-}

```{r}
devtools::session_info()
```







