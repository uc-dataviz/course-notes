# Showing the right numbers {#show-the-numbers}

```{r setup, cache = FALSE}
library(tidyverse)
library(gapminder)
library(socviz)
library(knitr)
library(broom)
library(forcats)
library(stringr)
library(ggrepel)
library(here)
```

## Learning objectives {-}

### Morning

* Expand on the different types of geometric objects used by `ggplot2`
* Demonstrate the ability of `ggplot2` to calculate statistical transformations
* Review the grammar of graphics and `ggplot2` workflow
* Combine `ggplot2` with `dplyr` and data transformation prior to constructing the graph

### Afternoon

* Demonstrate techniques for mapping data to graphics
* Introduce alternative visualizations for displaying amounts and proportions
* Consider advanced visualizations for comparisons

## Assigned readings {-}

* Chapters 4-5, @healy2018data - accessible via the [book's website](https://socviz.co/)

## Grammar of graphics (review)

The **grammar of graphics** is a set of rules for how to produce graphics from data, taking **pieces of data** and **mapping** them to **geometric objects** (like points and lines) that have **aesthetic attributes** (like position, color, and size), together with further rules for **transforming the data if needed**, adjusting **scales**, or projecting the results onto a **coordinate system**.

## Grouped data and the `group` aesthetic

```{r gapminder}
p <- ggplot(
  data = gapminder,
  mapping = aes(
    x = year,
    y = gdpPercap
  )
)

p + geom_line()
```

This doesn't look right. It is trying to draw a single line for all the observations. But look at the structure of `gapminder`:

```{r gapminder-print}
gapminder
```

It is one-row-per-country-per-year. We use `group` to identify the column that tells us this structure so we draw one line per country.

```{r gapminder-group}
p <- ggplot(data = gapminder, mapping = aes(
  x = year,
  y = gdpPercap
))
p + geom_line(mapping = aes(group = country))
```

```{r gapminder-facet}
p <- ggplot(
  data = gapminder,
  mapping = aes(
    x = year,
    y = gdpPercap
  )
)
p + geom_line(
  mapping =
    aes(group = country)
) +
  facet_wrap(~continent)
```

A **facet** is not a geom. It is a way of arranging geoms. Facet's use R's formula syntax. Read the `~` as "on" or "by".

```{r labs}
p + geom_line(
  color = "gray70",
  mapping = aes(group = country)
) +
  geom_smooth(
    size = 1.1,
    method = "loess",
    se = FALSE
  ) +
  scale_y_log10(labels = scales::dollar) +
  facet_wrap(~continent, ncol = 5) +
  labs(
    x = "Year",
    y = "GDP per capita",
    title = "GDP per capita on Five Continents"
  )
```

The `labs()` function lets you name labels, title, subtitle, etc.

## Geoms can transform data

```{r gss}
gss_sm
```

`gss_sm` contains a subset of General Social Survey questions from 2016.

```{r gss-relig}
count(x = gss_sm, religion)
```

```{r obtain-count}
p <- ggplot(
  data = gss_sm,
  mapping = aes(x = bigregion)
)
p + geom_bar()
```

The `y`-axis variable `count` is not in the data. Instead, ggplot has calculated it for us. It does this by using the default `stat_*()` function associated with `geom_bar()`, `stat_count()`. This function can compute two new variables, `count` and `prop` (short for **proportion**). The `count` statistic is the default one used.

```{r prop-wrong}
p <- ggplot(
  data = gss_sm,
  mapping = aes(x = bigregion)
)
p + geom_bar(mapping = aes(y = stat(prop)))
```

```{r prop-right}
p <- ggplot(
  data = gss_sm,
  mapping = aes(x = bigregion)
)
p + geom_bar(mapping = aes(y = stat(prop), group = 1))
```

By default `stat(prop)` is calculated within each bar. If you want to calculate the proportion of all the rows in the data frame, add `group = 1`.

## `geom_*()` functions call their default `stat_*()` functions behind the scenes

```r
p + geom_bar()

p + stat_count()
```

### Color in a bar chart

If you want to use color as an aesthetic to communicate additional information in a bar chart, pass it using the `fill` aesthetic. `color` defines the border of the bar.

```{r bar-chart-color}
p <- ggplot(
  data = gss_sm,
  mapping = aes(x = religion)
)
p + geom_bar()
p <- ggplot(
  data = gss_sm,
  mapping = aes(x = religion, color = religion)
)
p + geom_bar()
p <- ggplot(
  data = gss_sm,
  mapping = aes(x = religion, fill = religion)
)
p + geom_bar()
p <- ggplot(
  data = gss_sm,
  mapping = aes(x = religion, fill = religion)
)
p + geom_bar() + guides(fill = FALSE)
```

## Histograms and kernel densities

```{r midwest}
midwest
```

`midwest` contains county-level census data for Midwestern states.

```{r histogram}
p <- ggplot(
  data = midwest,
  mapping = aes(x = area)
)
p + geom_histogram()
```

The default `stat` for this geom has to make a choice, so the message is letting us know we might want to override it.

```{r histogram-10-bins}
p <- ggplot(
  data = midwest,
  mapping = aes(x = area)
)
p + geom_histogram(bins = 10)
```

### Subsetting data on the fly

```{r}
oh_wi <- c("OH", "WI")

p <- ggplot(
  data = filter(midwest, state %in% oh_wi),
  mapping = aes(x = percollege, fill = state)
)
p + geom_histogram(
  position = "identity",
  alpha = 0.4, bins = 20
)
```

While this can be done, it is somewhat challenging to read intuitively. You must use `alpha` to incorporate transparency otherwise all hope at interpreting is lost.

Alternatively, you could use a continuous counterpart, `geom_density()`.

```{r density}
p <- ggplot(
  data = midwest,
  mapping = aes(x = area)
)

p + geom_density()
```

```{r density-fill}
p <- ggplot(
  data = midwest,
  mapping = aes(
    x = area,
    fill = state,
    color = state
  )
)

p + geom_density(alpha = 0.3)
```

## Avoiding transformations when necessary

Sometimes no transformation is necessary. Consider the `titanic` dataset

```{r titanic}
titanic
```

Here the data has already been summarized. What if we want to make a bar chart?

```{r titanic-bar}
p <- ggplot(
  data = titanic,
  mapping = aes(
    x = fate,
    y = percent,
    fill = sex
  )
)
p + geom_bar(
  stat = "identity",
  position = "dodge"
) + theme(legend.position = "top")
```

Even more conveniently, use `geom_col()`

```{r titanic-col}
p <- ggplot(data = titanic, mapping = aes(
  x = fate,
  y = percent,
  fill = sex
))

p + geom_col(position = "dodge") + theme(legend.position = "top")
```

```{r oecd}
oecd_sum

p <- ggplot(
  data = oecd_sum,
  mapping = aes(x = year, y = diff, fill = hi_lo)
)
p + geom_col() + guides(fill = FALSE) + labs(
  x = NULL, y = "Difference in Years",
  title = "The US Life Expectancy Gap", subtitle = "Difference between US and OECD
average life expectancies, 1960-2015",
  caption = "Data: OECD. After a chart by Christopher Ingraham,
Washington Post, December 27th 2017."
)
```

## Cross-tabulation the awkward way

More commonly, we would add color to a bar graph to cross-classify two categorical variables. This is the graphical equivalent of a frequency table. We can do this directly within `ggplot()`, however it is also more convoluted.

Consider examining religious preference by census region.

```{r region-religion}
ggplot(
  data = gss_sm,
  mapping = aes(
    x = bigregion,
    fill = religion
  )
) +
  geom_bar()
```

By default we get a stacked bar chart. If we want to make comparisons easier, we could convert this to a proportional bar chart.

```{r region-religion-fill}
ggplot(
  data = gss_sm,
  mapping = aes(
    x = bigregion,
    fill = religion
  )
) +
  geom_bar(position = "fill")
```

Now all the bars are the same height, but we lost the ability to see the relative size of each region with respect to the overall total. What if we wanted to show the proportion of religions within regions of the country, but instead of stacking the bars we want separate bars? The first attempt may use `position = "dodge"`.

```{r region-religion-dodge}
ggplot(
  data = gss_sm,
  mapping = aes(
    x = bigregion,
    fill = religion
  )
) +
  geom_bar(position = "dodge")
```

Good structure, but we're back to counts. Let's directly map the `stat(prop)` variable to the `y` aesthetic as well to preserve the proportion on the y-axis.

```{r region-religion-dodge-prop}
ggplot(
  data = gss_sm,
  mapping = aes(
    x = bigregion,
    fill = religion
  )
) +
  geom_bar(mapping = aes(y = stat(prop)), position = "dodge")
```

Still not correct. Same problem as before. Each individual bar sums to 1. If we want overall proportions for a single variable, we mapped `group = 1`. What if we do that here but with respect to `religion`?

```{r region-religion-dodge-prop-religion}
ggplot(
  data = gss_sm,
  mapping = aes(
    x = bigregion,
    fill = religion
  )
) +
  geom_bar(mapping = aes(
    y = stat(prop),
    group = religion
  ), position = "dodge")
```

Looks better, but we still have a problem. Bars within a single region do not sum to 1. Instead, bars for any particular religion sum to 1.

```{r region-religion-facet}
ggplot(
  data = gss_sm,
  mapping = aes(x = religion)
) +
  geom_bar(mapping = aes(
    y = stat(prop),
    group = bigregion
  ), position = "dodge") +
  facet_wrap(~bigregion)
```

The easiest approach is to use `facet_wrap()` and not force `geom_bar()` and `stat_count()` to do all the work in a single step. Instead, we can ask `ggplot()` to give us a proportional bar chart of religious affiliation, and then facet that by region. The proportions are calculated within each panel, which is the breakdown we wanted. This has the added advantage of not producing too many bars within each category.

### Calculate manually

Rather than doing all the summarizing in `ggplot()`, we could instead calculate the frequencies and proportions manually using `dplyr` functions first, then use the summarized data frame as the basis for the bar graph.

```{r rel-by-region}
glimpse(gss_sm)

(rel_by_region <- gss_sm %>%
  count(bigregion, religion) %>%
  mutate(
    freq = n / sum(n),
    pct = round((freq * 100), 0)
  ) %>%
  drop_na())
```

Now this is easy to pass into `ggplot()` and draw the bar graph.

```{r rel-by-region-plot}
ggplot(
  data = rel_by_region,
  mapping = aes(
    x = bigregion,
    y = pct,
    fill = religion
  )
) +
  geom_col(position = "dodge2") +
  labs(x = "Region", y = "Percent", fill = "Religion") +
  theme(legend.position = "top")
```

Instead of using `geom_bar()`, we use `geom_col()` because we already summarized the data - we want `stat_identity()`, not `stat_count()`. While this figure works, it is not the best we can do. It is generally crowded. Instead, let's convert it to a faceted plot:

```{r rel-by-region-plot-facet}
ggplot(
  data = rel_by_region,
  mapping = aes(
    x = religion,
    y = pct,
    fill = religion
  )
) +
  geom_col(position = "dodge2") +
  labs(x = "Region", y = "Percent", fill = "Religion") +
  guides(fill = FALSE) +
  coord_flip() +
  facet_grid(~bigregion)
```

## Continuous variables by group or category

```{r organdata}
glimpse(organdata)
```

### Boxplots

```{r organ-box}
ggplot(
  data = organdata,
  mapping = aes(x = country, y = donors)
) +
  geom_boxplot()
```

Awkward to have country labels on x-axis. Switch to y-axis.

### `coord_flip()`

```{r organ-flip}
ggplot(
  data = organdata,
  mapping = aes(x = country, y = donors)
) +
  geom_boxplot() +
  coord_flip()
```

Explicit use of a coordinate transformation system.

### `reorder()`

```{r organ-reorder}
ggplot(
  data = organdata,
  mapping = aes(
    x = reorder(country, donors, na.rm = TRUE),
    y = donors
  )
) +
  geom_boxplot() +
  labs(x = NULL) +
  coord_flip()
```

Place on a more meaningful order.

Add color aesthetic.

```{r organ-world}
ggplot(
  data = organdata,
  mapping = aes(
    x = reorder(country, donors, na.rm = TRUE),
    y = donors, fill = world
  )
) +
  geom_boxplot() +
  labs(x = NULL) +
  coord_flip() +
  theme(legend.position = "bottom")
```

### Strip chart

```{r strip-chart}
ggplot(
  data = organdata,
  mapping = aes(
    x = reorder(country, donors, na.rm = TRUE),
    y = donors, color = world
  )
) +
  geom_point() +
  labs(x = NULL) +
  coord_flip() +
  theme(legend.position = "bottom")
```

Hard to see all the points. Add jitter.

```{r strip-jitter}
ggplot(
  data = organdata,
  mapping = aes(
    x = reorder(country, donors, na.rm = TRUE),
    y = donors, color = world
  )
) +
  geom_jitter() +
  labs(x = NULL) +
  coord_flip() +
  theme(legend.position = "bottom")
```

### Cleveland dotplot

#### Calculate summary statistics

```{r organ-sum}
(by_country <- organdata %>%
  group_by(consent_law, country) %>%
  summarize(
    donors_mean = mean(donors, na.rm = TRUE),
    donors_sd = sd(donors, na.rm = TRUE),
    gdp_mean = mean(gdp, na.rm = TRUE),
    health_mean = mean(health, na.rm = TRUE),
    roads_mean = mean(roads, na.rm = TRUE),
    cerebvas_mean = mean(cerebvas, na.rm = TRUE)
  ))
```

Better approach using efficient code.

```{r}
(by_country <- organdata %>%
  group_by(consent_law, country) %>%
  summarize(across(where(is.numeric), list(mean = mean, sd = sd), na.rm = TRUE)) %>%
  ungroup())
```

#### Draw the plot

```{r organ-donor-mean}
ggplot(
  data = by_country,
  mapping = aes(
    x = donors_mean,
    y = reorder(country, donors_mean),
    color = consent_law
  )
) +
  geom_point(size = 3) +
  labs(
    x = "Donor Procurement Rate",
    y = "", color = "Consent Law"
  ) +
  theme(legend.position = "top")
```

#### Use facet instead of color

```{r organ-donor-facet}
ggplot(
  data = by_country,
  mapping = aes(
    x = donors_mean,
    y = reorder(country, donors_mean)
  )
) +
  geom_point(size = 3) +
  facet_wrap(~consent_law, ncol = 1) +
  labs(
    x = "Donor Procurement Rate",
    y = "", color = "Consent Law"
  )
```

```{r organ-free-scale-y}
ggplot(
  data = by_country,
  mapping = aes(
    x = donors_mean,
    y = reorder(country, donors_mean)
  )
) +
  geom_point(size = 3) +
  facet_wrap(~consent_law, scales = "free_y", ncol = 1) +
  labs(
    x = "Donor Procurement Rate",
    y = "", color = "Consent Law"
  )
```

Allow the $y$-axis to vary and only include matching countries.

#### Add standard deviation

```{r organ-donor-sd}
ggplot(
  data = by_country,
  mapping = aes(
    x = reorder(country, donors_mean),
    y = donors_mean
  )
) +
  geom_pointrange(mapping = aes(
    ymin = donors_mean - donors_sd,
    ymax = donors_mean + donors_sd
  )) +
  labs(
    x = "",
    y = "Donor Procurement Rate"
  ) +
  coord_flip()
```

## Plot text directly

### `geom_text()`

```{r geom-text}
ggplot(
  data = by_country,
  mapping = aes(
    x = roads_mean,
    y = donors_mean
  )
) +
  geom_point() +
  geom_text(mapping = aes(label = country))
```

```{r geom-text-adj}
ggplot(
  data = by_country,
  mapping = aes(
    x = roads_mean,
    y = donors_mean
  )
) +
  geom_point() +
  geom_text(mapping = aes(label = country), hjust = 0)
```

## `ggrepel::geom_text_repel()`

```{r elections}
elections_historic %>%
  select(2:7)
```

```{r elections-plot}
p_title <- "Presidential Elections: Popular & Electoral College Margins"
p_subtitle <- "1824-2016"
p_caption <- "Data for 2016 are provisional."
x_label <- "Winner's share of Popular Vote"
y_label <- "Winner's share of Electoral College Votes"

library(ggrepel)

ggplot(data = elections_historic, mapping = aes(
  x = popular_pct,
  y = ec_pct,
  label = winner_label
)) +
  geom_hline(yintercept = 0.5, size = 1.4, color = "gray80") +
  geom_vline(xintercept = 0.5, size = 1.4, color = "gray80") +
  geom_point() +
  geom_text_repel() +
  scale_x_continuous(labels = scales::percent) +
  scale_y_continuous(labels = scales::percent) +
  labs(
    x = x_label, y = y_label, title = p_title, subtitle = p_subtitle,
    caption = p_caption
  )
```

### Label outliers only

```{r label-outliers}
ggplot(
  data = by_country,
  mapping = aes(x = gdp_mean, y = health_mean)
) +
  geom_point() +
  geom_text_repel(
    data = filter(by_country, gdp_mean > 25000),
    mapping = aes(label = country)
  )

ggplot(
  data = by_country,
  mapping = aes(x = gdp_mean, y = health_mean)
) +
  geom_point() +
  geom_text_repel(
    data = filter(
      by_country,
      gdp_mean > 25000 | health_mean < 1500 |
        country %in% "Belgium"
    ),
    mapping = aes(label = country)
  )
```

## Scales, guides, and themes

```{r gapminder-scales}
p <- ggplot(
  data = gapminder,
  mapping =
    aes(
      x = gdpPercap,
      y = lifeExp,
      color = continent, fill = continent
    )
)

p + geom_point() +
  geom_smooth(method = "loess") +
  scale_x_log10()
```

Scale functions control scale mappings in geoms. Remember: not just `x` and `y` but also `color`, `fill`, `shape`, and `size` are scales. They visually represent quantities or categories in your data -- thus, they have a scale associated with that
representation. This means you control things like color schemes for data mappings through **scale functions**.

```r
scale_<MAPPING>_<KIND>()

scale_x_continuous()
scale_y_continuous()
scale_x_discrete()
scale_y_discrete()
scale_x_log10()
scale_x_sqrt()
```

### Labels, breaks, and limits

```{r labs-breaks-limits}
p <- ggplot(
  data = organdata,
  mapping = aes(
    x = roads,
    y = donors, color = world
  )
)

p + geom_point() +
  scale_x_log10() + scale_y_continuous(
    breaks = c(5, 15, 25),
    labels = c("Five", "Fifteen", "Twenty Five")
  )
```

```{r scale-color}
p <- ggplot(
  data = organdata,
  mapping = aes(
    x = roads,
    y = donors, color = world
  )
)

p + geom_point() + scale_color_discrete(
  labels =
    c(
      "Corporatist", "Liberal",
      "Social Democratic", "Unclassified"
    )
) +
  labs(
    x = "Road Deaths",
    y = "Donor Procurement",
    color = "Welfare State"
  )
```

```{r guides-off}
p <- ggplot(data = organdata, mapping = aes(
  x = roads,
  y = donors, color = world
))
p + geom_point() +
  labs(
    x = "Road Deaths",
    y = "Donor Procurement"
  ) + guides(color = FALSE)
```

## Mapping data to graphics

```{block2, type = "rmdnote", echo = TRUE}
Download the necessary data files for the following coding exercises using `usethis::use_course("css-data-mining-viz/show-the-numbers")`.

```

For this example, I'm going to use real world data to demonstrate the typical process for loading data, cleaning it up a bit, and mapping specific columns of the data onto the parts of a graph using the grammar of graphics and `ggplot()`. 

The data I'll use comes from the BBC's corporate charity, [BBC Children in Need](https://www.bbcchildreninneed.co.uk/), which makes grants to smaller UK nonprofit organizations that work on issues related to childhood poverty. An organization in the UK named [360Giving](https://www.threesixtygiving.org/) helps nonprofits and foundations publish data about their grant giving activities in an open and standardized way, and (as of May 2020) [they list data from 126 different charities](http://data.threesixtygiving.org/), including BBC Children in Need.

If you want to follow along with this example (highly recommended!), you can download the data directly from [the website](https://data-mining-viz.netlify.app/data/360-giving-data.xlsx).

### Load and clean data

First, we need to load a few libraries: **tidyverse** (as always), along with **readxl** for reading Excel files and **lubridate** for working with dates:

```{r load-libraries-map-data, warning=FALSE, message=FALSE}
# Load libraries
library(tidyverse)  # For ggplot, dplyr, and friends
library(readxl)     # For reading Excel files
library(lubridate)  # For working with dates
```

We'll then load the original Excel file. I placed this file in a folder named `data` in my RStudio Project folder for this example. It's also good practice to keep a pristine, untouched copy of your data. 

```{r load-bbc-data-fake, eval=FALSE}
# Load the original Excel file
bbc_raw <- read_excel("data/360-giving-data.xlsx")
```

```{r load-bbc-data, include=FALSE, warning=FALSE}
bbc_raw <- read_excel(here::here("data", "360-giving-data.xlsx"))
```

There may be some errors reading the file -- you can ignore those in this case.

Next we'll add a couple columns and clean up the data a little.

We'll extract the year from the Award Date column, rename some of the longer-named columns, and make a new column that shows the duration of grants. We'll also get rid of 2015 since there are so few observations then.

Note the strange use of `` ` ``s around column names like `` `Award Date` ``. This is because R technically doesn't allow special characters like spaces in column names. If there are spaces, you have to wrap the column names in backticks. Because typing backticks all the time gets tedious, we'll use `rename()` to rename some of the columns: 

```{r clean-bbc-data}
bbc <- bbc_raw %>% 
  # Extract the year from the award date
  mutate(grant_year = year(`Award Date`)) %>% 
  # Rename some columns
  rename(grant_amount = `Amount Awarded`,
         grant_program = `Grant Programme:Title`,
         grant_duration = `Planned Dates:Duration (months)`) %>% 
  # Make a new text-based version of the duration column, recoding months
  # between 12-23, 23-35, and 36+. The case_when() function here lets us use
  # multiple if/else conditions at the same time.
  mutate(grant_duration_text = case_when(
    grant_duration >= 12 & grant_duration < 24 ~ "1 year",
    grant_duration >= 24 & grant_duration < 36 ~ "2 years",
    grant_duration >= 36 ~ "3 years"
  )) %>% 
  # Get rid of anything before 2016
  filter(grant_year > 2015) %>% 
  # Make a categorical version of the year column
  mutate(grant_year_category = factor(grant_year))
```

### Histograms

First let's look at the distribution of grant amounts with a histogram. Map `grant_amount` to the x-axis and don't map anything to the y-axis, since `geom_histogram()` will calculate the y-axis values for us:

```{r hist-basic}
ggplot(data = bbc, mapping = aes(x = grant_amount)) +
  geom_histogram()
```

Notice that ggplot warns you about bin widths. By default it will divide the data into 30 equally spaced bins, which will most likely not be the best for your data. You should *always* set your own bin width to something more appropriate. There are no rules for correct bin widths. Just don't have them be too wide:

```{r hist-wide-bin}
ggplot(data = bbc, mapping = aes(x = grant_amount)) +
  geom_histogram(binwidth = 100000)
```

Or too small:

```{r hist-tiny-bins}
ggplot(data = bbc, mapping = aes(x = grant_amount)) +
  geom_histogram(binwidth = 500)
```

£10,000 seems to fit well. It's often helpful to add a white border to the histogram bars, too:

```{r hist-good-bins}
ggplot(data = bbc, mapping = aes(x = grant_amount)) +
  geom_histogram(binwidth = 10000, color = "white")
```

We can map other variables onto the plot, like mapping `grant_year_category` to the fill aesthetic:

```{r hist-bad-fill}
ggplot(bbc, aes(x = grant_amount, fill = grant_year_category)) +
  geom_histogram(binwidth = 10000, color = "white")
```

That gets really hard to interpret though, so we can facet by year with `facet_wrap()`:

```{r hist-facet-fill}
ggplot(bbc, aes(x = grant_amount, fill = grant_year_category)) +
  geom_histogram(binwidth = 10000, color = "white") +
  facet_wrap(vars(grant_year))
```

Neat!

### Points

Next let's look at the data using points, mapping year to the x-axis and grant amount to the y-axis:

```{r points-initial}
ggplot(bbc, aes(x = grant_year_category, y = grant_amount)) +
  geom_point()
```

We have some serious overplotting here, with dots so thick that it looks like lines. We can fix this a couple different ways. First, we can make the points semi-transparent using `alpha`, which ranges from 0 (completely invisible) to 1 (completely solid).

```{r points-alpha}
ggplot(bbc, aes(x = grant_year_category, y = grant_amount)) +
  geom_point(alpha = 0.1)
```

We can also randomly space the points to spread them out using `position_jitter()`:

```{r points-jitter-default}
ggplot(bbc, aes(x = grant_year_category, y = grant_amount)) +
  geom_point(position = position_jitter())
```

One issue with this, though, is that the points are jittered along the x-axis (which is fine, since they're all within the same year) *and* the y-axis (which is bad, since the amounts are actual numbers). We can tell ggplot to only jitter in one direction by specifying the `height` argument—we don't want any up-and-down jittering:

```{r points-jitter-horizontal-only}
ggplot(bbc, aes(x = grant_year_category, y = grant_amount)) +
  geom_point(position = position_jitter(height = 0))
```

There are some weird clusters around £30,000 and below. Let's map `grant_program` to the color aesthetic, which has two categories—regular grants and small grants—and see if that helps explain why:

```{r points-jitter-color}
ggplot(bbc, aes(x = grant_year_category, y = grant_amount, color = grant_program)) +
  geom_point(position = position_jitter(height = 0))
```

It does! We appear to have two different distributions of grants: small grants have a limit of £30,000, while regular grants have a much higher average amount.

### Boxplots

We can add summary information to the plot by only changing the `geom` we're using. Switch from `geom_point()` to `geom_boxplot()`:

```{r boxplot}
ggplot(bbc, aes(x = grant_year_category, y = grant_amount, color = grant_program)) +
  geom_boxplot()
```

### Summaries

We can also make smaller summarized datasets with **dplyr** functions like `group_by()` and `summarize()` and plot those. First let's look at grant totals, averages, and counts over time:

```{r make-data-year}
bbc_by_year <- bbc %>% 
  group_by(grant_year) %>%  # Make invisible subgroups for each year
  summarize(total = sum(grant_amount),  # Find the total awarded in each group
            avg = mean(grant_amount),  # Find the average awarded in each group
            number = n())  # n() is a special function that shows the number of rows in each group

# Look at our summarized data
bbc_by_year
```

Because we used `summarize()`, R shrank our data down significantly. We now only have a row for each of the subgroups we made: one for each year. We can plot this smaller data. We'll use `geom_col()` for now.

```{r plot-year-summaries}
# Plot our summarized data
ggplot(bbc_by_year, aes(x = grant_year, y = avg)) +
  geom_col()

ggplot(bbc_by_year, aes(x = grant_year, y = total)) +
  geom_col()

ggplot(bbc_by_year, aes(x = grant_year, y = number)) +
  geom_col()
```

Based on these charts, it looks like 2016 saw the largest average grant amount. In all other years, grants averaged around £60,000, but in 2016 it jumped up to £80,000. If we look at total grants, though, we can see that there were far fewer grants awarded in 2016—only 221! 2017 and 2018 were much bigger years with far more money awarded.

We can also use multiple aesthetics to reveal more information from the data. First we'll make a new small summary dataset and group by both year and grant program. With those groups, we'll again calculate the total, average, and number.

```{r make-data-year-size}
bbc_year_size <- bbc %>% 
  group_by(grant_year, grant_program) %>% 
  summarize(total = sum(grant_amount),
            avg = mean(grant_amount),
            number = n())
bbc_year_size
```

Next we'll plot the data, mapping the `grant_program` column to the `fill` aesthetic:

```{r plot-year-size}
ggplot(bbc_year_size, aes(x = grant_year, y = total, fill = grant_program)) +
  geom_col()
```

By default, ggplot will stack the different fill colors within the same bar, but this makes it a little hard to make comparisons. While we can see that the average small grant amount was a little bigger in 2017 than in 2019, it's harder to compare average main grant amount, since the bottoms of those sections don't align.

To fix this, we can use `position_dodge()` to tell the columns to fit side-by-side:

```{r plot-year-size-dodge}
ggplot(bbc_year_size, aes(x = grant_year, y = total, fill = grant_program)) +
  geom_col(position = position_dodge())
```

Instead of dodging, we can also facet by `grant_program` to separate the bars:

```{r plot-year-size-facet}
ggplot(bbc_year_size, aes(x = grant_year, y = total, fill = grant_program)) +
  geom_col() +
  facet_wrap(vars(grant_program))
```

We can put these in one column if we want:

```{r plot-year-size-col}
ggplot(bbc_year_size, aes(x = grant_year, y = total, fill = grant_program)) +
  geom_col() +
  facet_wrap(vars(grant_program), ncol = 1)
```

Finally, we can include even more variables! We have a lot of aesthetics we can work with (`size`, `alpha`, `color`, `fill`, `linetype`, etc.), as well as facets, so let's add one more to show the duration of the awarded grant.

First we'll make another smaller summarized dataset, grouping by year, program, and duration and summarizing the total, average, and number of awards.

```{r make-data-year-size-duration}
bbc_year_size_duration <- bbc %>% 
  group_by(grant_year, grant_program, grant_duration_text) %>% 
  summarize(total = sum(grant_amount),
            avg = mean(grant_amount),
            number = n())
bbc_year_size_duration
```

Next, we'll fill by grant program and facet by duration and show the total number of grants awarded

```{r plot-year-size-duration}
ggplot(bbc_year_size_duration, aes(x = grant_year, y = number, fill = grant_program)) +
  geom_col(position = position_dodge(preserve = "single")) +
  facet_wrap(vars(grant_duration_text), ncol = 1)
```

The vast majority of BBC Children in Need's grants last for 3 years. Super neat.

## Amounts and proportions

For this example, we're going to use real world data to demonstrate some different ways to visualize amounts and proportions. We'll use data from the CDC and the Social Security Administration about the number of daily births in the United States from 1994–2014. [FiveThirtyEight reported a story using this data in 2016](https://fivethirtyeight.com/features/some-people-are-too-superstitious-to-have-a-baby-on-friday-the-13th/) and they posted relatively CSV files [on GitHub](https://github.com/fivethirtyeight/data/tree/master/births), so we can download and use those.

If you want to follow along with this example, you can download the data directly from [GitHub](https://github.com/fivethirtyeight/data/tree/master/births) or by using these links (you'll likely need to right click on these and choose "Save Link As…"):

* [`US_births_1994-2003_CDC_NCHS.csv`](https://raw.githubusercontent.com/fivethirtyeight/data/master/births/US_births_1994-2003_CDC_NCHS.csv)
* [`US_births_2000-2014_SSA.csv`](https://raw.githubusercontent.com/fivethirtyeight/data/master/births/US_births_2000-2014_SSA.csv)

### Load data

There are two CSV files:

- `US_births_1994-2003_CDC_NCHS.csv` contains U.S. births data for the years 1994 to 2003, as provided by the Centers for Disease Control and Prevention’s National Center for Health Statistics.
- `US_births_2000-2014_SSA.csv` contains U.S. births data for the years 2000 to 2014, as provided by the Social Security Administration.

Since the two datasets overlap in 2000–2003, we use Social Security Administration data for those years.

We downloaded the data from GitHub and placed the CSV files in a folder named `data`. We'll then load them with `read_csv()` and combine them into one data frame.

```{r load-libraries-data-fake, eval=FALSE}
library(tidyverse)
library(scales)   # For nice labels in charts
births_1994_1999 <- read_csv("data/US_births_1994-2003_CDC_NCHS.csv") %>% 
  # Ignore anything after 2000
  filter(year < 2000)
births_2000_2014 <- read_csv("data/US_births_2000-2014_SSA.csv")
births_combined <- bind_rows(births_1994_1999, births_2000_2014)
```

```{r load-libraries-data-real, include=FALSE, warning=FALSE, message=FALSE}
library(tidyverse)
library(scales)
births_1994_1999 <- read_csv(here::here( "data", "US_births_1994-2003_CDC_NCHS.csv")) %>%
  # Ignore anything after 2000
  filter(year < 2000)
births_2000_2014 <- read_csv(here::here("data", "US_births_2000-2014_SSA.csv"))
births_combined <- bind_rows(births_1994_1999, births_2000_2014)
```

### Wrangle data

Let's look at the first few rows of the data to see what we're working with:

```{r head-data}
births_combined
```

The columns for year and births seem straightforward and ready to use. The columns for month and day of the week could be improved if we changed them to text (i.e. January instead of 1; Tuesday instead of 3). To fix this, we can convert these columns to categorical variables, or factors in R. We can also specify that these categories (or factors) are ordered, meaning that Feburary comes after January, etc. Without ordering, R will plot them alphabetically, which isn't very helpful.

We'll make a new dataset named `births` that's based on the combined births data, but with some new columns added:

```{r wrangle-data}
# The c() function lets us make a list of values
month_names <- c("January", "February", "March", "April", "May", "June", "July",
                 "August", "September", "October", "November", "December")

day_names <- c("Monday", "Tuesday", "Wednesday", 
               "Thursday", "Friday", "Saturday", "Sunday")

births <- births_combined %>% 
  # Make month an ordered factor, using the month_name list as labels
  mutate(month = factor(month, labels = month_names, ordered = TRUE)) %>% 
  mutate(day_of_week = factor(day_of_week, labels = day_names, ordered = TRUE),
         date_of_month_categorical = factor(date_of_month)) %>% 
  # Add a column indicating if the day is on a weekend
  mutate(weekend = ifelse(day_of_week %in% c("Saturday", "Sunday"), TRUE, FALSE))

head(births)
```

If you look at the data now, you can see the columns are changed and have different types. `year` and `date_of_month` are still numbers, but `month`, and `day_of_week` are ordered factors (`ord`) and `date_of_month_categorical` is a regular factor (`fct`). Technically it's also ordered, but because it's already alphabetical (i.e. 2 naturally comes after 1), we don't need to force it to be in the right order.

Our `births` data is now clean and ready to go!

### Bar plot

First we can look at a bar chart showing the total number of births each day. We need to make a smaller summarized dataset and then we'll plot it:

```{r plot-bar-chart}
total_births_weekday <- births %>% 
  group_by(day_of_week) %>% 
  summarize(total = sum(births))

ggplot(data = total_births_weekday,
       mapping = aes(x = day_of_week, y = total, fill = day_of_week)) +
  geom_col() +
  # Turn off the fill legend because it's redundant
  guides(fill = FALSE)
```

If we fill by day of the week, we get 7 different colors, which is fine (I guess), but doesn't really help tell a story. The main story here is that there are far fewer births during weekends. If we create a new column that flags if a row is Saturday or Sunday, we can fill by that column instead:

```{r plot-bar-chart-weekend}
total_births_weekday <- births %>% 
  group_by(day_of_week) %>% 
  summarize(total = sum(births)) %>% 
  mutate(weekend = day_of_week %in% c("Saturday", "Sunday"))

ggplot(data = total_births_weekday,
       mapping = aes(x = day_of_week, y = total, fill = weekend)) +
  geom_col()
```

Neat! Those default colors are kinda ugly, though, so let's use the principles of preattentive processing and contrast to highlight the weekend bars:

```{r plot-bar-chart-weekend-better}
ggplot(data = total_births_weekday,
       mapping = aes(x = day_of_week, y = total, fill = weekend)) +
  geom_col() +
  # Use grey and orange
  scale_fill_manual(values = c("grey70", "#f2ad22")) +
  # Use commas instead of scientific notation
  scale_y_continuous(labels = comma) +
  # Turn off the legend since the title shows what the orange is
  guides(fill = FALSE) +
  labs(title = "Weekends are unpopular times for giving birth",
       x = NULL, y = "Total births")
```

### Lollipop chart

Since the ends of the bars are often the most important part of the graph, we can use a lollipop chart to emphasize them. We'll keep all the same code from our bar chart and make a few changes:

- Color by weekend instead of fill by weekend, since points and lines are colored in ggplot, not filled
- Switch `scale_fill_manual()` to `scale_color_manual()` and turn off the `color` legend in the `guides()` layer 
- Switch `geom_col()` to `geom_pointrange()`. The `geom_pointrange()` layer requires two additional aesthetics: `ymin` and `ymax` for the ends of the lines that come out of the point. Here we'll set `ymin` to 0 so it starts at the x-axis, and we'll set `ymax` to `total` so it ends at the point.

```{r plot-lollipop-chart-weekend-better}
ggplot(data = total_births_weekday,
       mapping = aes(x = day_of_week, y = total, color = weekend)) +
  geom_pointrange(aes(ymin = 0, ymax = total),
                  # Make the lines a little thicker and the dots a little bigger
                  fatten = 5, size = 1.5) +
  # Use grey and orange
  scale_color_manual(values = c("grey70", "#f2ad22")) +
  # Use commas instead of scientific notation
  scale_y_continuous(labels = comma) +
  # Turn off the legend since the title shows what the orange is
  guides(color = FALSE) +
  labs(title = "Weekends are unpopular times for giving birth",
       x = NULL, y = "Total births")
```


### Strip plot

Let's show all the data with points. We'll use the full dataset now, map `x` to weekday, `y` to births, and change `geom_col()` to `geom_point()`. We'll tell `geom_point()` to jitter the points randomly.

```{r strip-plot}
ggplot(data = births,
       mapping = aes(x = day_of_week, y = births, color = weekend)) +
  scale_color_manual(values = c("grey70", "#f2ad22")) +
  geom_point(size = 0.5, position = position_jitter(height = 0)) +
  guides(color = FALSE)
```

There are some interesting points in the low ends, likely because of holidays like Labor Day and Memorial Day (for the Mondays) and Thanksgiving (for the Thursday). If we had a column that indicated whether a day was a holiday, we could color by that and it would probably explain most of those low numbers. Unfortunately we don't have that column, and it'd be hard to make. Some holidays are constant (Halloween is always October 31), but some aren't (Thanksgiving is the fourth Thursday in November, so we'd need to find out which November 20-somethingth each year is the fourth Thursday, and good luck doing that at scale).

### Beeswarm plot

We can add some structure to these points if we use the [**ggbeeswarm** package](https://github.com/eclarke/ggbeeswarm), with either `geom_beeswarm()` or `geom_quasirandom()`. `geom_quasirandom()` actually works better here since there are so many points -- `geom_beeswarm()` makes the clusters of points way too wide.

```{r beeswarm-plot}
library(ggbeeswarm)
ggplot(data = births,
       mapping = aes(x = day_of_week, y = births, color = weekend)) +
  scale_color_manual(values = c("grey70", "#f2ad22")) +
  # Make these points suuuper tiny
  geom_quasirandom(size = 0.0001) +
  guides(color = FALSE)
```

### Heatmap

Finally, let's use something non-traditional to show the average births by day in a somewhat proportional way. We can calculate the average number of births every day and then make a heatmap that fills each square by that average, thus showing the relative differences in births per day.

To do this, we need to make a summarized data frame with `group_by() %>% summarize()` to calculate the average number of births by month and day of the month (i.e. average for January 1, January 2, etc.).

We'll then make a sort of calendar with date of the month on the x axis, month on the y axis, with heat map squares filled by the daily average. We'll use `geom_tile()` to add squares for each day, and then add some extra scale, coordinates, and theme layers to clean up the plot:

```{r plot-heatmap, fig.width=10, fig.height=4}
avg_births_month_day <- births %>% 
  group_by(month, date_of_month_categorical) %>% 
  summarize(avg_births = mean(births))

ggplot(data = avg_births_month_day,
       # By default, the y-axis will have December at the top, so use fct_rev() to reverse it
       mapping = aes(x = date_of_month_categorical, y = fct_rev(month), fill = avg_births)) +
  geom_tile() +
  # Add viridis colors
  scale_fill_viridis_c(option = "inferno", labels = comma) + 
  # Add nice labels
  labs(x = "Day of the month", y = NULL,
       title = "Average births per day",
       subtitle = "1994-2014",
       fill = "Average births") +
  # Force all the tiles to have equal widths and heights
  coord_equal() +
  # Use a cleaner theme
  theme_minimal()
```

Neat! There are some really interesting trends here. Most obvious, probably, is that very few people are born on New Year's Day, July 4th, Halloween, Thanksgiving, and Christmas. 

```{r lowest-days}
avg_births_month_day %>% 
  arrange(avg_births)
```

The days with the highest average are in mid-September, likely because that's about 9 months after the first week of January. July 7th at #7 is odd and I have no idea why it might be so popular.

```{r highest-days}
avg_births_month_day %>% 
  arrange(desc(avg_births))
```

The funniest trend is the very visible dark column for the 13th of every month. People *really* don't want to give birth on the 13th.

## Comparisons

For this example, we're going to use cross-national data, but instead of using the typical `gapminder` dataset, we're going to collect data directly from the [World Bank's Open Data portal](https://data.worldbank.org/)

If you want to skip the data downloading, you can download the data below (you'll likely need to right click and choose "Save Link As…"):

* [`wdi_raw.csv`](https://data-mining-viz.netlify.app/data/wdi_raw.csv)

### Load and clean data

First, we load the libraries we'll be using:

```{r load-libraries-comparisons}
library(tidyverse)  # For ggplot, dplyr, and friends
library(WDI)        # For getting data from the World Bank
library(geofacet)   # For map-shaped facets
library(scales)     # For helpful scale functions like dollar()
library(ggrepel)    # For non-overlapping labels
```

The World Bank has a ton of country-level data at [data.worldbank.org](https://data.worldbank.org/). We can use [a package named **WDI**](https://cran.r-project.org/package=WDI) (**w**orld **d**evelopment **i**ndicators) to access their servers and download the data directly into R.

To do this, we need to find the special World Bank codes for specific variables we want to get. These codes come from the URLs of the World Bank's website. For instance, if you search for "access to electricity" at the World Bank's website, you'll find [this page](https://data.worldbank.org/indicator/EG.ELC.ACCS.ZS). If you look at the end of the URL, you'll see a cryptic code: `EG.ELC.ACCS.ZS`. That's the World Bank's ID code for the "Access to electricity (% of population)" indicator.

We can feed a list of ID codes to the `WDI()` function to download data for those specific indicators. We want data from 1995-2015, so we set the start and end years accordingly. The `extra=TRUE` argument means that it'll also include other helpful details like region, aid status, etc. Without it, it would only download the indicators we listed.

```{r get-wdi-data, eval=FALSE}
indicators <- c("SP.DYN.LE00.IN",  # Life expectancy
                "EG.ELC.ACCS.ZS",  # Access to electricity
                "EN.ATM.CO2E.PC",  # CO2 emissions
                "NY.GDP.PCAP.KD")  # GDP per capita

wdi_raw <- WDI(country = "all", indicators, extra = TRUE, 
               start = 1995, end = 2015)

head(wdi_raw)
```

Downloading data from the World Bank every time you knit will get tedious and take a long time (plus if their servers are temporarily down, you won't be able to get the data). It's good practice to save this raw data as a CSV file and then work with that.

```{r write-csv, eval=FALSE}
write_csv(wdi_raw, "data/wdi_raw.csv")
```

```{r write-csv-real, eval=FALSE, include=FALSE}
write_csv(wdi_raw, here::here("data", "wdi_raw.csv"))
```

```{r load-data-real, include=FALSE}
wdi_raw <- read_csv(here::here("data", "wdi_raw.csv"))
```

Then we clean up the data a little, filtering out rows that aren't actually countries and renaming the ugly World Bank code columns to actual words:

```{r clean-wdi-data}
wdi_clean <- wdi_raw %>% 
  filter(region != "Aggregates") %>% 
  select(iso2c, country, year, 
         life_expectancy = SP.DYN.LE00.IN, 
         access_to_electricity = EG.ELC.ACCS.ZS, 
         co2_emissions = EN.ATM.CO2E.PC, 
         gdp_per_cap = NY.GDP.PCAP.KD, 
         region, income)

head(wdi_clean)
```

### Small multiples

First we can make some small multiples plots and show life expectancy over time for a handful of countries. We'll make a list of some countries chosen at random while I scrolled through the data, and then filter our data to include only those rows. We then plot life expectancy, faceting by country.

```{r life-expectancy-small}
life_expectancy_small <- wdi_clean %>%
  filter(country %in% c("Afghanistan", "Belarus", "India",
                        "Mexico", "New Zealand", "Spain"))

ggplot(data = life_expectancy_small, 
       mapping = aes(x = year, y = life_expectancy)) +
  geom_line(size = 1) +
  facet_wrap(vars(country))
```

Small multiples! That's all we need to do.

We can do some fancier things, though. We can make this plot hyper minimalist:

```{r life-expectancy-small-minimalist}
ggplot(data = life_expectancy_small, 
       mapping = aes(x = year, y = life_expectancy)) +
  geom_line(size = 1) +
  facet_wrap(vars(country), scales = "free_y") +
  theme_void() +
  theme(strip.text = element_text(face = "bold"))
```

We can do a whole part of a continent (poor Iraq and Syria)

```{r life-expectancy-mena, fig.width=10, fig.height=3.5}
life_expectancy_mena <- wdi_clean %>% 
  filter(region == "Middle East & North Africa")

ggplot(data = life_expectancy_mena, 
       mapping = aes(x = year, y = life_expectancy)) +
  geom_line(size = 1) +
  facet_wrap(vars(country), scales = "free_y", nrow = 3) +
  theme_void() +
  theme(strip.text = element_text(face = "bold"))
```

We can use the [**geofacet** package](https://hafen.github.io/geofacet/) to arrange these facets by geography:

```{r life-expectancy-eu, warning=FALSE, message=FALSE, fig.width=10, fig.height=8}
life_expectancy_eu <- wdi_clean %>% 
  filter(region == "Europe & Central Asia")

ggplot(life_expectancy_eu, aes(x = year, y = life_expectancy)) +
  geom_line(size = 1) +
  facet_geo(vars(country), grid = "eu_grid1", scales = "free_y") +
  labs(x = NULL, y = NULL, title = "Life expectancy from 1995–2015",
       caption = "Source: The World Bank (SP.DYN.LE00.IN)") +
  theme_minimal() +
  theme(strip.text = element_text(face = "bold"),
        plot.title = element_text(face = "bold"),
        axis.text.x = element_text(angle = 45, hjust = 1))
```

Neat!

### Sparklines

Sparklines are just line charts (or bar charts) that are really really small.

```{r india-spark, fig.width=1, fig.height=0.15, fig.asp = NULL, out.width = NULL, warning=FALSE}
india_co2 <- wdi_clean %>% 
  filter(country == "India")

plot_india <- ggplot(india_co2, aes(x = year, y = co2_emissions)) +
  geom_line() +
  theme_void()
plot_india
```

```{r save-india-fake, eval=FALSE}
ggsave("india_co2.pdf", plot_india, width = 1, height = 0.15, units = "in")
ggsave("india_co2.png", plot_india, width = 1, height = 0.15, units = "in")
```

```{r china-spark, fig.width=1, fig.height=0.15, fig.asp = NULL, out.width = NULL, warning=FALSE}
china_co2 <- wdi_clean %>% 
  filter(country == "China")

plot_china <- ggplot(china_co2, aes(x = year, y = co2_emissions)) +
  geom_line() +
  theme_void()
plot_china
```

```{r save-china-fake, eval=FALSE}
ggsave("china_co2.pdf", plot_china, width = 1, height = 0.15, units = "in")
ggsave("china_co2.png", plot_china, width = 1, height = 0.15, units = "in")
```

You can then use those saved tiny plots in your text.

> Both India <img class="img-inline" src="https://data-mining-viz.netlify.app/images/india-spark-1.png" width = "100"/> and China <img class="img-inline" src="https://data-mining-viz.netlify.app/images/china-spark-1.png" width = "100"/> have seen increased CO~2~ emissions over the past 20 years.

### Slopegraphs

We can make a slopegraph to show changes in GDP per capita between two time periods. We need to first filter our WDI to include only the start and end years (here 1995 and 2015). Then, to make sure that we're using complete data, we'll get rid of any country that has missing data for either 1995 or 2015. The `group_by(...) %>% filter(...) %>% ungroup()` pipeline does this, with the `!any(is.na(gdp_per_cap))` test keeping any rows where any of the `gdp_per_cap` values are not missing for the whole country.

We then add a couple special columns for labels. The `paste0()` function concatenates strings and variables together, so that `paste0("2 + 2 = ", 2 + 2)` would show "2 + 2 = 4". Here we make labels that say either "Country name: \$GDP" or "\$GDP" depending on the year.

```{r slopegraph-sa-data}
gdp_south_asia <- wdi_clean %>% 
  filter(region == "South Asia") %>% 
  filter(year %in% c(1995, 2015)) %>% 
  # Look at each country individually
  group_by(country) %>%
  # Remove the country if any of its gdp_per_cap values are missing
  filter(!any(is.na(gdp_per_cap))) %>%
  ungroup() %>%
  # Make year a factor
  mutate(year = factor(year)) %>% 
  # Make some nice label columns
  # If the year is 1995, format it like "Country name: $GDP". If the year is
  # 2015, format it like "$GDP"
  mutate(label_first = ifelse(year == 1995, str_c(country, ": ", dollar(round(gdp_per_cap))), NA),
         label_last = ifelse(year == 2015, dollar(round(gdp_per_cap, 0)), NA))
```

With the data filtered like this, we can plot it by mapping year to the x-axis, GDP per capita to the y-axis, and coloring by country. To make the lines go across the two categorical labels in the x-axis (since we made year a factor/category), we need to also specify the `group` aesthetic.

```{r slopegraph-sa-simple}
ggplot(gdp_south_asia, aes(x = year, y = gdp_per_cap, group = country, color = country)) +
  geom_line(size = 1.5)
```

Cool! We're getting closer. We can definitely see different slopes, but with 7 different colors, it's hard to see exactly which country is which. Instead, we can directly label each of these lines with `geom_text()`:

```{r slopegraph-sa-simple-text}
ggplot(gdp_south_asia, aes(x = year, y = gdp_per_cap, group = country, color = country)) +
  geom_line(size = 1.5) +
  geom_text(aes(label = country)) +
  guides(color = FALSE)
```

That gets us a *little* closer, but the country labels are hard to see, and we could include more information, like the actual values. Remember those `label_first` and `label_last` columns we made? Let's use those instead:

```{r slopegraph-sa-simple-text-fancier, warning=FALSE}
ggplot(gdp_south_asia, aes(x = year, y = gdp_per_cap, group = country, color = country)) +
  geom_line(size = 1.5) +
  geom_text(aes(label = label_first)) +
  geom_text(aes(label = label_last)) +
  guides(color = FALSE)
```

Now we have dollar amounts and country names, but the labels are still overlapping and really hard to read. To fix this, we can make the labels repel away from each other and randomly position in a way that makes them not overlap. The [**ggrepel** package](https://cran.r-project.org/web/packages/ggrepel/vignettes/ggrepel.html) lets us do this with `geom_text_repel()`

```{r slopegraph-sa-getting-warmer, warning=FALSE}
ggplot(gdp_south_asia, aes(x = year, y = gdp_per_cap, group = country, color = country)) +
  geom_line(size = 1.5) +
  geom_text_repel(aes(label = label_first)) +
  geom_text_repel(aes(label = label_last)) +
  guides(color = FALSE)
```

Now none of the labels are on top of each other, but the labels are still on top of the lines. Also, some of the labels moved inward and outward along the x-axis, but they don't need to do that—they just need to shift up and down. We can force the labels to only move up and down by setting the `direction = "y"` argument, and we can move all the labels to the left or right with the `nudge_x` argument. The `seed` argument makes sure that the random label placement is the same every time we run this. It can be whatever number you want—it just has to be a number.

```{r slopegraph-sa-fancier, warning=FALSE}
ggplot(gdp_south_asia, aes(x = year, y = gdp_per_cap, group = country, color = country)) +
  geom_line(size = 1.5) +
  geom_text_repel(aes(label = label_first), direction = "y", nudge_x = -1, seed = 1234) +
  geom_text_repel(aes(label = label_last), direction = "y", nudge_x = 1, seed = 1234) +
  guides(color = FALSE)
```

That's it! Let's take the theme off completely, change the colors a little, and it should be perfect.

```{r slopegraph-sa-done, warning=FALSE}
ggplot(gdp_south_asia, aes(x = year, y = gdp_per_cap, group = country, color = country)) +
  geom_line(size = 1.5) +
  geom_text_repel(aes(label = label_first), direction = "y", nudge_x = -1, seed = 1234) +
  geom_text_repel(aes(label = label_last), direction = "y", nudge_x = 1, seed = 1234) +
  guides(color = FALSE) +
  scale_color_viridis_d(option = "magma", end = 0.9) +
  theme_void()
```

### Bump charts

Finally, we can make a bump chart that shows changes in rankings over time. We'll look at CO~2~ emissions in South Asia. First we need to calculate a new variable that shows the rank of each country within each year. We can do this if we group by year and then use the `rank()` function to rank countries by the `co2_emissions` column.

```{r filter-bump-data}
sa_co2 <- wdi_clean %>% 
  filter(region == "South Asia") %>% 
  filter(year >= 2004, year < 2015) %>% 
  group_by(year) %>% 
  mutate(rank = rank(co2_emissions))
```

We then plot this with points and lines, reversing the y-axis so 1 is at the top:

```{r make-bump-plot}
ggplot(sa_co2, aes(x = year, y = rank, color = country)) +
  geom_line() +
  geom_point() +
  scale_y_reverse(breaks = 1:8)
```

Afghanistan and Nepal switched around for the number 1 spot, while India dropped from 4 to 6, switching places with Pakistan.

As with the slopegraph, there are 8 different colors in the legend and it's hard to line them all up with the different lines, so we can plot the text directly instead. We'll use `geom_text()` again. We don't need to repel anything, since the text should fit in each row just fine. We need to change the `data` argument in `geom_text()` though and filter the data to only include one year, otherwise we'll get labels on every point, which is excessive. We can also adjust the theme and colors to make it cleaner.

```{r bump-plot-fancier, fig.width=7, fig.height=4.2}
ggplot(sa_co2, aes(x = year, y = rank, color = country)) +
  geom_line(size = 2) +
  geom_point(size = 4) +
  geom_text(data = filter(sa_co2, year == 2004),
            aes(label = iso2c, x = 2003.25),
            fontface = "bold") +
  geom_text(data = filter(sa_co2, year == 2014),
            aes(label = iso2c, x = 2014.75),
            fontface = "bold") +
  guides(color = FALSE) +
  scale_y_reverse(breaks = 1:8) +
  scale_x_continuous(breaks = 2004:2014) +
  scale_color_viridis_d(option = "magma", begin = 0.2, end = 0.9) +
  labs(x = NULL, y = "Rank") +
  theme_minimal() +
  theme(panel.grid.major.y = element_blank(),
        panel.grid.minor.y = element_blank(),
        panel.grid.minor.x = element_blank())
```

If you want to be *super* fancy, you can use flags instead of country codes, but that's a little more complicated (you need to install the [**ggflags** package](https://github.com/rensa/ggflags). [See here for an example](https://dominikkoch.github.io/Bump-Chart/).

## Acknowledgments {-}

* Coding examples from [Andrew Heiss](https://datavizm20.classes.andrewheiss.com)

## Session info {-}

```{r}
devtools::session_info()
```
